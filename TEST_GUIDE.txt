╔══════════════════════════════════════════════════════════════════════════════════════╗
║                            راهنمای کامل تست پروژه                                   ║
║                        Complete Testing Guide                                        ║
║                            پروژه کامپایلر - گروه 15                                 ║
╚══════════════════════════════════════════════════════════════════════════════════════╝

🎯 هدف:
════════════════════════════════════════════════════════════════════════════════════════
اطمینان از کارکرد صحیح تمام بخش‌های پروژه قبل از تحویل


📦 فایل‌های تست (3 فایل):
════════════════════════════════════════════════════════════════════════════════════════

1️⃣ test_quick.py ⚡
   📄 تست سریع 30 ثانیه‌ای
   ✓ 7 تست اصلی
   ✓ بررسی عملکرد parser
   ✓ مناسب برای: چک سریع بعد از تغییرات

2️⃣ test_comprehensive.py 🧪
   📄 تست جامع (2-3 دقیقه)
   ✓ 8 دسته تست (40+ تست)
   ✓ بررسی همه artifact ها
   ✓ بررسی سازگاری
   ✓ نمره‌دهی خودکار
   ✓ مناسب برای: تست نهایی قبل از تحویل

3️⃣ TEST_GUIDE.txt (این فایل)
   📄 راهنمای کامل تست


═══════════════════════════════════════════════════════════════════════════════════════
🚀 روش 1: تست سریع (30 ثانیه)
═══════════════════════════════════════════════════════════════════════════════════════

زمان: 30 ثانیه
هدف: اطمینان از کارکرد اصلی parser

دستور:
────────────────────────────────────────────────────────────────────────────────────
python test_quick.py

چه چیزهایی را تست می‌کند؟
  ✓ توانایی import کردن parser
  ✓ پارس 6 دستور مختلف:
    - CLFLUSH [EAX] (رجیستر ساده)
    - CLFLUSHOPT [EBX+16] (با offset مثبت)
    - PREFETCHT0 [ECX-8] (با offset منفی)
    - WBINVD (بدون operand)
    - CLWB [cache_line] (با شناسه)
    - PREFETCHNTA [RAX+128] (با offset بزرگ)

نتیجه موفق:
────────────────────────────────────────────────────────────────────────────────────
📊 نتیجه: 7 موفق، 0 ناموفق
🎉 عالی! همه تست‌ها موفق بود. پارسر درست کار می‌کند!

نتیجه ناموفق:
────────────────────────────────────────────────────────────────────────────────────
⚠️  X تست ناموفق بود. کد را بررسی کنید.


═══════════════════════════════════════════════════════════════════════════════════════
🧪 روش 2: تست جامع (2-3 دقیقه)
═══════════════════════════════════════════════════════════════════════════════════════

زمان: 2-3 دقیقه
هدف: تست کامل تمام بخش‌ها

دستور:
────────────────────────────────────────────────────────────────────────────────────
python test_comprehensive.py

8 دسته تست:
────────────────────────────────────────────────────────────────────────────────────

تست 1: وجود فایل‌های ضروری
  بررسی می‌کند:
  • main.py, cache_lexer.py, cache_parser.py, lr_tables.py
  • grammar.txt, SHIFT_REDUCE_ANALYSIS.txt
  • lr0_automata, LR_PARSING_TABLE_ASCII.txt
  • README.md, .gitignore, LICENSE

تست 2: Import های پایتون
  بررسی می‌کند:
  • نصب PLY (Python Lex-Yacc)
  • توانایی import ماژول‌های پروژه
  • سازگاری نسخه Python

تست 3: عملکرد Parser
  بررسی می‌کند:
  • پارس 6 دستور مختلف
  • صحت AST تولید شده
  • مدیریت خطاها

تست 4: جداول LR(0)
  بررسی می‌کند:
  • تعداد state ها (باید 17 باشد)
  • تعداد قوانین گرامر (باید 18 باشد)
  • وجود state 0 و accept state

تست 5: سازگاری گرامر
  بررسی می‌کند:
  • وجود 18 قانون در grammar.txt
  • وجود قوانین کلیدی (instruction, mnemonic, operand, ...)
  • تطابق با lr_tables.py

تست 6: کیفیت مستندات
  بررسی می‌کند:
  • وجود README.md با محتوای کافی
  • وجود هدرها، بلوک‌های کد، لینک‌ها
  • طول مناسب (بیش از 200 خط)

تست 7: فایل‌های مثال JSON
  بررسی می‌کند:
  • وجود فایل‌های JSON مثال
  • صحت فرمت JSON
  • محتوای معنادار

تست 8: فایل‌های اتوماتا
  بررسی می‌کند:
  • وجود فایل lr0_automata (DOT)
  • تعداد state ها (باید 17 باشد)
  • وجود تصویر (.png, .jpg, .pdf)

نتیجه:
────────────────────────────────────────────────────────────────────────────────────
╔══════════════════════════════════════════════════════════════════════════════════╗
║                        خلاصه نتایج تست‌ها                                      ║
╚══════════════════════════════════════════════════════════════════════════════════╝

تعداد کل تست‌ها: 45
موفق: 42
ناموفق: 0
هشدارها: 3

🎉 همه چیز عالیه! پروژه آماده تحویل است.

نمره کلی: 93.3/100


═══════════════════════════════════════════════════════════════════════════════════════
💻 روش 3: تست دستی در برنامه اصلی
═══════════════════════════════════════════════════════════════════════════════════════

برای تست تعاملی:

دستور:
────────────────────────────────────────────────────────────────────────────────────
python main.py

منوها:
  1. پارس یک دستور - وارد کن: CLFLUSH [EAX]
  2. نمایش خروجی JSON - بررسی فرمت JSON
  3. پارس فایل Assembly - تست چند دستور همزمان
  4. نمایش جدول LR(0) - بررسی جدول
  5. تحلیل دستی Shift-Reduce - دیدن trace
  6. اجرای تست‌های خودکار - تست داخلی برنامه
  7. نمایش قوانین گرامر - بررسی گرامر
  8. حالت تعاملی - آزمایش آزاد
  9. نمایش نمودار Automata - دیدن اتوماتا
  10. درباره پروژه - اطلاعات

مثال تست:
────────────────────────────────────────────────────────────────────────────────────
انتخاب منو: 1

دستور Assembly را وارد کنید: CLFLUSHOPT [EBX+16]

✅ پارس موفق!

Parse Tree:
Instruction: CLFLUSHOPT
├─ Operand:
   └─ MemoryOperand:
      ├─ Base: Register(EBX, 32-bit)
      └─ Offset: +16


═══════════════════════════════════════════════════════════════════════════════════════
🔍 روش 4: تست تک‌تک ماژول‌ها
═══════════════════════════════════════════════════════════════════════════════════════

برای تست هر بخش جداگانه:

تست Lexer:
────────────────────────────────────────────────────────────────────────────────────
python -c "
from cache_lexer import lexer
lexer.input('CLFLUSH [EAX]')
for tok in lexer:
    print(tok)
"

نتیجه انتظاری:
  LexToken(CLFLUSH,'CLFLUSH',1,0)
  LexToken(LBRACKET,'[',1,8)
  LexToken(REGISTER,'EAX',1,9)
  LexToken(RBRACKET,']',1,12)


تست Parser:
────────────────────────────────────────────────────────────────────────────────────
python -c "
from cache_parser import parse_instruction
result = parse_instruction('CLFLUSH [EAX]')
print(result)
print(type(result))
"

نتیجه انتظاری:
  Instruction(mnemonic=CLFLUSH, operand=MemoryOperand(...))
  <class 'cache_parser.Instruction'>


تست LR Tables:
────────────────────────────────────────────────────────────────────────────────────
python -c "
from lr_tables import LR_PARSING_TABLE, GRAMMAR_RULES
print(f'States: {len(LR_PARSING_TABLE)}')
print(f'Rules: {len(GRAMMAR_RULES)}')
print(f'State 0: {0 in LR_PARSING_TABLE}')
"

نتیجه انتظاری:
  States: 17
  Rules: 18
  State 0: True


═══════════════════════════════════════════════════════════════════════════════════════
📊 روش 5: بررسی سازگاری Artifact ها
═══════════════════════════════════════════════════════════════════════════════════════

چک‌لیست دستی:

□ گرامر ↔ lr_tables.py
  - باز کن: grammar.txt
  - شمارش قوانین (باید 18 باشد)
  - مقایسه با GRAMMAR_RULES در lr_tables.py
  - تطابق 100%؟ ✅

□ اتوماتا ↔ lr_tables.py
  - باز کن: lr0_automata
  - شمارش state ها (بگرد "State 0", "State 1", ...)
  - باید 17 state باشد (0-16)
  - مقایسه با LR_PARSING_TABLE
  - تطابق 100%؟ ✅

□ جدول LR ↔ lr_tables.py
  - باز کن: LR_PARSING_TABLE_ASCII.txt
  - شمارش سطرهای جدول (17 سطر برای 17 state)
  - مقایسه با LR_PARSING_TABLE
  - تطابق 100%؟ ✅

□ مثال‌ها ↔ گرامر
  - باز کن: SHIFT_REDUCE_ANALYSIS.txt
  - بررسی 6 مثال
  - همه باید با قوانین R1-R18 سازگار باشند
  - هیچ قانون دیگری استفاده نشده؟ ✅


═══════════════════════════════════════════════════════════════════════════════════════
🐛 حل مشکلات رایج
═══════════════════════════════════════════════════════════════════════════════════════

مشکل 1: "ModuleNotFoundError: No module named 'ply'"
────────────────────────────────────────────────────────────────────────────────────
راه‌حل:
  pip install ply

یا:
  pip install -r requirements.txt


مشکل 2: "SyntaxError" در هنگام اجرا
────────────────────────────────────────────────────────────────────────────────────
راه‌حل:
  • بررسی نسخه Python (باید 3.8+ باشد)
  • اجرای: python --version
  • اگر Python 2 است، از python3 استفاده کنید


مشکل 3: تست‌ها می‌گویند parser کار نمی‌کند
────────────────────────────────────────────────────────────────────────────────────
راه‌حل:
  1. بررسی وجود فایل parsetab.py (ممکن است نیاز به حذف داشته باشد)
     rm parsetab.py
     rm parser.out

  2. اجرای مجدد parser:
     python cache_parser.py

  3. اجرای مجدد تست


مشکل 4: "UnicodeDecodeError"
────────────────────────────────────────────────────────────────────────────────────
راه‌حل:
  • فایل‌ها باید با encoding UTF-8 ذخیره شوند
  • در VSCode: File → Preferences → Settings → encoding → UTF-8


مشکل 5: تست‌ها فایل‌ها را پیدا نمی‌کنند
────────────────────────────────────────────────────────────────────────────────────
راه‌حل:
  • اطمینان از اجرا در پوشه صحیح:
    cd /path/to/project
    ls -la  # باید main.py و cache_parser.py را ببینید

  • اجرای مجدد تست از همان پوشه


═══════════════════════════════════════════════════════════════════════════════════════
✅ چک‌لیست نهایی قبل از تحویل
═══════════════════════════════════════════════════════════════════════════════════════

تست‌های فنی:
□ test_quick.py اجرا شد - همه موفق ✅
□ test_comprehensive.py اجرا شد - نمره بالای 90 ✅
□ main.py اجرا می‌شود و منو نمایش می‌دهد ✅
□ منوی 1 کار می‌کند (پارس یک دستور) ✅
□ منوی 6 کار می‌کند (تست‌های خودکار) ✅

بررسی Artifact ها:
□ تمام فایل‌های ضروری موجودند ✅
□ گرامر دارای 18 قانون است ✅
□ اتوماتا دارای 17 state است ✅
□ جدول LR با lr_tables.py سازگار است ✅
□ مثال‌ها با R1-R18 سازگارند ✅

GitHub:
□ Repository ساخته شده ✅
□ README.md با محتوای کامل ✅
□ همه فایل‌ها push شده‌اند ✅
□ لینک در گزارش قرار گرفته ✅

گزارش:
□ لینک GitHub در گزارش است ✅
□ تصویر اتوماتا در گزارش است ✅
□ جدول LR در گزارش است ✅
□ مثال‌های trace در گزارش است ✅


═══════════════════════════════════════════════════════════════════════════════════════
📈 معیارهای موفقیت
═══════════════════════════════════════════════════════════════════════════════════════

سطح پایه (حداقل):
  ✓ test_quick.py → 6/7 تست موفق
  ✓ parser دستورات ساده را پارس می‌کند
  ✓ main.py اجرا می‌شود

سطح خوب (پیشنهادی):
  ✓ test_quick.py → 7/7 تست موفق
  ✓ test_comprehensive.py → نمره بالای 85
  ✓ تمام artifact ها موجودند
  ✓ مستندات کامل است

سطح عالی (ایده‌آل):
  ✓ test_comprehensive.py → نمره بالای 95
  ✓ تطابق 100% بین artifact ها
  ✓ GitHub repository حرفه‌ای
  ✓ مستندات جامع و دقیق
  ✓ بدون هیچ هشدار


═══════════════════════════════════════════════════════════════════════════════════════
⏱️ زمان‌بندی تست قبل از تحویل
═══════════════════════════════════════════════════════════════════════════════════════

2 روز قبل از تحویل:
  • اجرای test_comprehensive.py
  • رفع مشکلات و هشدارها
  • به‌روزرسانی مستندات

1 روز قبل از تحویل:
  • اجرای مجدد test_comprehensive.py
  • تست GitHub repository
  • بررسی نهایی گزارش

صبح روز تحویل:
  • test_quick.py (فقط 30 ثانیه)
  • چک لینک GitHub
  • آماده برای ارسال! ✅


═══════════════════════════════════════════════════════════════════════════════════════
💡 نکات مهم
═══════════════════════════════════════════════════════════════════════════════════════

1. تست منظم:
   بعد از هر تغییر مهم، test_quick.py را اجرا کنید

2. تست قبل از commit:
   قبل از هر commit به GitHub، تست کنید

3. تست در محیط تمیز:
   یک بار در یک virtual environment تمیز تست کنید:
   python -m venv test_env
   source test_env/bin/activate  # Windows: test_env\Scripts\activate
   pip install -r requirements.txt
   python test_comprehensive.py

4. تست در سیستم دیگر (اختیاری):
   اگر ممکن است، روی کامپیوتر دیگری هم تست کنید

5. ذخیره نتایج تست:
   python test_comprehensive.py > test_results.txt


═══════════════════════════════════════════════════════════════════════════════════════
📞 کمک بیشتر
═══════════════════════════════════════════════════════════════════════════════════════

اگر تست‌ها مشکلی نشان دادند:
  1. خطا را کامل بخوانید
  2. بخش "حل مشکلات رایج" را بررسی کنید
  3. اگر حل نشد، کد را مرور کنید
  4. از تست‌های دستی (روش 4) استفاده کنید


تاریخ تهیه: 5 فوریه 2026
نسخه: 2.0
وضعیت: آماده برای استفاده ✅
